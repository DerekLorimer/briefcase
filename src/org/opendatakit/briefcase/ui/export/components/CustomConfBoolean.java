package org.opendatakit.briefcase.ui.export.components;

import static org.opendatakit.briefcase.ui.export.components.CustomConfBoolean.Value.INHERIT;
import static org.opendatakit.briefcase.ui.export.components.CustomConfBoolean.Value.NO;
import static org.opendatakit.briefcase.ui.export.components.CustomConfBoolean.Value.YES;

import java.awt.FlowLayout;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.function.Consumer;
import javax.swing.ButtonGroup;
import javax.swing.JComponent;
import javax.swing.JPanel;
import javax.swing.JRadioButton;

@SuppressWarnings({"checkstyle:CommentsIndentation", "checkstyle:MethodName"})
public class CustomConfBoolean {
  private JPanel container;
  JRadioButton inherit;
  JRadioButton yes;
  JRadioButton no;
  private final List<Consumer<Value>> onChangeCallbacks = new ArrayList<>();
  private Value lastValue;

  public CustomConfBoolean(Optional<Value> initialValue) {
    ButtonGroup buttonGroup = new ButtonGroup();
    buttonGroup.add(inherit);
    buttonGroup.add(yes);
    buttonGroup.add(no);

    switch (initialValue.orElse(INHERIT)) {
      case INHERIT:
        inherit.setSelected(true);
        break;
      case YES:
        yes.setSelected(true);
        break;
      case NO:
        no.setSelected(true);
        break;
      default:
        // This one is because checkstyle will complain about not having a default branch
        // I guess it prevents regression if we add new values to the enum, which wouldn't
        // make sense in the first place. If Java starts supporting pattern matching, we
        // can get rid of this.
        throw new IllegalArgumentException("Unsupported value " + initialValue);
    }

    inherit.addActionListener(__ -> setInternal(INHERIT));
    yes.addActionListener(__ -> setInternal(YES));
    no.addActionListener(__ -> setInternal(NO));
  }

  public void onChange(Consumer<Value> callback) {
    onChangeCallbacks.add(callback);
  }

  public void set(Value value) {
    switch (value) {
      case INHERIT:
        inherit.setSelected(true);
        break;
      case YES:
        yes.setSelected(true);
        break;
      case NO:
        no.setSelected(true);
        break;
      default:
        throw new IllegalArgumentException("Unsupported value " + value);
    }
  }

  void setInternal(Value value) {
    if (lastValue != value) {
      lastValue = value;
      onChangeCallbacks.forEach(callback -> callback.accept(value));
    }
  }

  public void setVisible(boolean visible) {
    container.setVisible(visible);
  }

  public void setEnabled(boolean enabled) {
    container.setEnabled(enabled);
    inherit.setEnabled(enabled);
    yes.setEnabled(enabled);
    no.setEnabled(enabled);
  }

  public Value get() {
    return lastValue;
  }

  {
// GUI initializer generated by IntelliJ IDEA GUI Designer
// >>> IMPORTANT!! <<<
// DO NOT EDIT OR ADD ANY CODE HERE!
    $$$setupUI$$$();
  }

  /**
   * Method generated by IntelliJ IDEA GUI Designer
   * >>> IMPORTANT!! <<<
   * DO NOT edit this method OR call it in your code!
   *
   * @noinspection ALL
   */
  private void $$$setupUI$$$() {
    container = new JPanel();
    container.setLayout(new FlowLayout(FlowLayout.CENTER, 5, 5));
    inherit = new JRadioButton();
    inherit.setText("Inherit");
    container.add(inherit);
    yes = new JRadioButton();
    yes.setText("Yes");
    container.add(yes);
    no = new JRadioButton();
    no.setText("No");
    container.add(no);
  }

  /**
   * @noinspection ALL
   */
  public JComponent $$$getRootComponent$$$() {
    return container;
  }

  public enum Value {
    INHERIT(Optional.empty()), YES(Optional.of(true)), NO(Optional.of(false));

    private final Optional<Boolean> booleanValue;

    Value(Optional<Boolean> booleanValue) {
      this.booleanValue = booleanValue;
    }

    public Optional<Boolean> getBooleanValue() {
      return booleanValue;
    }
  }

}
